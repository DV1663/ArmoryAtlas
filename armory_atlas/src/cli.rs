use crate::config::AppConfig;
use chrono::NaiveDate;
use clap::{Args, Parser, Subcommand};

#[derive(Parser)]
#[command(
    author,
    version,
    about = "A tool for managing the Armory Atlas database and inventory system"
)]
pub struct Command {
    #[arg(
        short,
        long,
        help = "The user to use when connecting to the database. Note that this will override whats written in the config file"
    )]
    pub user: Option<String>,
    #[arg(
        short = 'H',
        long,
        help = "The host to use when connecting to the database. Note that this will override whats written in the config file"
    )]
    pub host: Option<String>,
    #[arg(
        short,
        long,
        help = "The database to use when connecting to the database. Note that this will override whats written in the config file"
    )]
    pub database: Option<String>,
    #[command(subcommand)]
    pub subcommands: CommandType,
}

#[derive(Subcommand)]
pub enum CommandType {
    #[command(about = "Configure the app to use a different database")]
    Config(AppConfig),
    #[command(
        about = "Subcommands for generating the diffrent kind of data for the database, everything except for Products and the ID's for the items are generated by the app, ID's are delt with by the database"
    )]
    Generate(GenerateArgs),
    #[command(
        about = "Subcommands for managing the database, such as creating or dropping tables, triggers, procedures, functions and views"
    )]
    Manage(ManageArgs),
    #[command(about = "Subcommands for getting data from the database")]
    Get(GetArgs),
    #[command(about = "Subcommands for returning a borowed item")]
    Return(ReturnArgs),
    #[command(about = "Subcommands for inserting data into the database")]
    Insert(InsertArgs),
}

#[derive(Args, Debug, Clone)]
pub struct InsertArgs {
    #[command(subcommand)]
    pub subcommands: InsertSubCommands,
}

#[derive(Subcommand, Debug, Clone)]
pub enum InsertSubCommands {
    Item(InsertItemArgs),
    User(InsertUserArgs),
    Loan(InsertLoanArgs),
    Product(InsertProductArgs),
}

#[derive(Args, Debug, Clone)]
pub struct InsertItemArgs {
    #[arg(help = "The Product ID of the item to insert")]
    pub product_id: String,
    #[arg(help = "The size of the item to insert")]
    pub size: String,
    #[arg(help = "The quality of the item to insert")]
    pub quality: f32,
}

#[derive(Args, Debug, Clone)]
pub struct InsertUserArgs {
    #[arg(help = "The Social Security Number of the user to insert")]
    pub ssn: String,
    #[arg(help = "The name of the user to insert")]
    pub name: String,
}

#[derive(Args, Debug, Clone)]
pub struct InsertLoanArgs {
    #[arg(help = "The Social Security Number of the user that is making the loan")]
    pub ssn: String,
    #[arg(help = "The ID of the item that is being borrowed")]
    pub item_id: String,
    #[arg(help = "The date that the loan was made")]
    pub borrow_date: NaiveDate,
    #[arg(
        short,
        long,
        long_help = "The date that the loan was returned. This should only be used if the loan was made before this system was implemented!"
    )]
    pub return_date: Option<NaiveDate>,
}

#[derive(Args, Debug, Clone)]
pub struct InsertProductArgs {
    #[arg(
        help = "The ID of the product to insert. Must be unique and no longer then 16 chars long!"
    )]
    pub product_id: String,
    #[arg(help = "The name of the product to insert")]
    pub product_name: String,
    #[arg(help = "The type of the product to insert")]
    pub product_type: String,
}

#[derive(Args, Debug, Clone)]
pub struct ReturnArgs {
    #[command(subcommand)]
    pub subcommands: ReturnSubCommands,
}

#[derive(Subcommand, Debug, Clone)]
pub enum ReturnSubCommands {
    Item(ReturnItemArgs),
}

#[derive(Args, Debug, Clone)]
pub struct ReturnItemArgs {
    #[arg(help = "The ID of the item to return")]
    pub item_id: String,
}

#[derive(Args, Debug, Clone)]
pub struct GetArgs {
    #[command(subcommand)]
    pub subcommands: GetSubCommands,
}

#[derive(Subcommand, Debug, Clone)]
pub enum GetSubCommands {
    #[command(about = "Get Items from the database")]
    Items(GetItemsArgs),
    #[command(about = "Get whats in stock for the given product ID and size")]
    InStock(InStockArgs),
    #[command(about = "Get all loans or for one user")]
    Loans(GetLoansArgs),
    #[command(about = "Get all users")]
    Users(GetUsersArgs),
    #[command(about = "Get the number of loans for each user, both current and total")]
    NumberOfLoans(NumberOfLoansArgs),
}

#[derive(Args, Debug, Clone)]
pub struct NumberOfLoansArgs {
    #[arg(long, short)]
    pub limit: Option<usize>,
}

#[derive(Args, Debug, Clone)]
pub struct GetUsersArgs {
    pub limit: Option<usize>,
}

#[derive(Args, Debug, Clone)]
pub struct GetLoansArgs {
    #[arg(help = "If provided will only return loans for the given ssn")]
    pub ssn: Option<String>,
    #[arg(long, short)]
    pub limit: Option<usize>,
}

#[derive(Args, Debug, Clone)]
pub struct GetItemsArgs {
    pub limit: Option<usize>,
}

#[derive(Args, Debug, Clone)]
pub struct InStockArgs {
    #[arg(default_value = "M240001-3708453", help = "Product ID of the product")]
    pub pruduct_id: String,
    #[arg(default_value = "M", help = "Size of the product")]
    pub size: String,
}

#[derive(Args, Debug, Clone)]
pub struct ManageArgs {
    #[arg(short, long)]
    pub drop_all: bool,
    #[arg(short, long)]
    pub create_all: bool,
}

#[derive(Subcommand, Debug, Clone)]
pub enum GenerateSubCommands {
    #[command(about = "Generate Products")]
    Products,
    #[command(about = "Generate Items")]
    Items(ItemsArgs),
    #[command(about = "Generate Users")]
    Users(UsersArgs),
    #[command(about = "Generate Loans")]
    Loans(LoansArgs),
}

#[derive(Args, Debug, Clone)]
pub struct UsersArgs {
    #[arg(default_value = "10", help = "Number of users to generate")]
    pub num_users: usize,
}

#[derive(Args, Debug, Clone)]
pub struct LoansArgs {
    #[arg(default_value = "10", help = "Number of loans to generate")]
    pub num_loans: usize,
}

#[derive(Args, Debug, Clone)]
pub struct ItemsArgs {
    #[arg(default_value = "10", help = "Number of items to generate")]
    pub num_items: usize,
}

#[derive(Args, Debug, Clone)]
pub struct GenerateArgs {
    #[command(subcommand)]
    pub subcommands: Option<GenerateSubCommands>,

    #[arg(
        short,
        long,
        default_value = "10",
        help = "Number of rows to generate for each catagory if no subcommand is provided"
    )]
    pub num_to_generate: Option<usize>,
}
